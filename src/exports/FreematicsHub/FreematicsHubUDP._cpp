bool TeleClientUDP::verifyChecksum(char* data)
{
  uint8_t sum = 0;
  char *s = strrchr(data, '*');
  if (!s) return false;
  for (char *p = data; p < s; p++) sum += *p;
  if (hex2uint8(s + 1) == sum) {
    *s = 0;
    return true;
  }
  return false;
}

bool TeleClientUDP::notify(byte event, const char* payload)
{
  char buf[48];
  CStorageRAM netbuf;
  netbuf.init(128);
  netbuf.header(devid);
  netbuf.dispatch(buf, sprintf(buf, "EV=%X", (unsigned int)event));
  // ticker time in milliseconds
  netbuf.dispatch(buf, sprintf(buf, "TS=%lu", millis()));
  // local device time in seconds
  struct timeval timeval1;
  gettimeofday(&timeval1, NULL);
  uint32_t timestampSec = timeval1.tv_sec;
  netbuf.dispatch(buf, sprintf(buf, "TM=%lu", timestampSec));
  netbuf.dispatch(buf, sprintf(buf, "ID=%s", devid));
  if (vin[0]) {
    netbuf.dispatch(buf, sprintf(buf, "VIN=%s", vin));
  }
  if (payload) {
    netbuf.dispatch(payload, strlen(payload));
  }
  netbuf.tailer();
  //Serial.println(netbuf.buffer());
  for (byte attempts = 0; attempts < 3; attempts++) {
    // send notification datagram
    //Serial.println(netbuf.buffer());
    if (!net.send(netbuf.buffer(), netbuf.length())) {
      // error sending data
      break;
    }
#if NET_DEVICE != NET_SERIAL
    if (event == EVENT_ACK) return true; // no reply for ACK
    char *data = 0;
    // receive reply
    uint32_t t = millis();
    do {
      if ((data = net.receive())) break;
      // no reply yet
      delay(100);
    } while (millis() - t < DATA_RECEIVING_TIMEOUT);
    if (!data) {
      //Serial.println("Timeout");
      continue;
    }
    // verify checksum
    if (!verifyChecksum(data)) {
      Serial.print("Checksum mismatch:");
      Serial.println(data);
      continue;
    }
    char pattern[16];
    sprintf(pattern, "EV=%u", event);
    if (!strstr(data, pattern)) {
      Serial.println("Invalid reply");
      continue;
    }
    if (event == EVENT_LOGIN) {
      // extract info from server response
      char *p = strstr(data, "TM=");
      unsigned long t_seconds = 0;
      unsigned long t_microseconds = 0;
      if (p) {
        t_seconds = atol(p + 3);
      }
      p = strstr(data, "TN=");
      if (p) {
        t_microseconds = atol(p + 3);
      }
      if (t_seconds > 0) {
        // set local time from server
        struct timeval tv = { .tv_sec = (time_t)t_seconds, .tv_usec = (time_t)t_microseconds };
        settimeofday(&tv, NULL);
      }
      p = strstr(data, "SN=");
      if (p) {
        char *q = strchr(p, ',');
        if (q) *q = 0;
      }
      feedid = hex2uint16(data);
      login = true;
    } else if (event == EVENT_LOGOUT) {
      login = false;
    }
#endif
    // success
    return true;
  }
  return false;
}

bool TeleClientUDP::connect()
{
  byte event = login ? EVENT_RECONNECT : EVENT_LOGIN;
  bool success = false;
  // connect to telematics server
  for (byte attempts = 0; attempts < 5; attempts++) {
    Serial.print(event == EVENT_LOGIN ? "LOGIN(" : "RECONNECT(");
    Serial.print(SERVER_HOST);
    Serial.print(':');
    Serial.print(SERVER_PORT);
    Serial.println(")...");
    if (!net.open(SERVER_HOST, SERVER_PORT)) {
      Serial.println("Unable to connect");
      delay(3000);
      continue;
    }
    // log in or reconnect to Freematics Hub
    if (!notify(event)) {
      net.close();
      Serial.println("Server timeout");
      continue;
    }
    success = true;
    break;
  }
  startTime = millis();
  if (success) {
    lastSyncTime = startTime;
  }
  return success;
}

bool TeleClientUDP::ping()
{
  bool success = false;
  for (byte n = 0; n < 2 && !success; n++) {
    success = net.open(SERVER_HOST, SERVER_PORT);
    if (success) success = notify(EVENT_PING);
  }
  if (success) lastSyncTime = millis();
  return success;
}

bool TeleClientUDP::transmit(const char* packetBuffer, unsigned int packetSize)
{
  bool success = false;
  // transmit data
  if (net.send(packetBuffer, packetSize)) {
    txBytes += packetSize;
    txCount++;
    success = true;
  }
  return success;
}

void TeleClientUDP::inbound()
{
  // check incoming datagram
  do {
    int len = 0;
    char *data = net.receive(&len, 0);
    if (!data) break;
    data[len] = 0;
    rxBytes += len;
    if (!verifyChecksum(data)) {
      Serial.print("Checksum mismatch:");
      Serial.println(data);
      break;
    }
    char *p = strstr(data, "EV=");
    if (!p) break;
    int eventID = atoi(p + 3);
    switch (eventID) {
    case EVENT_COMMAND:
      processCommand(data);
      break;
    case EVENT_SYNC:
        {
          uint16_t id = hex2uint16(data);
          if (id && id != feedid) {
            feedid = id;
            Serial.print("FEED ID:");
            Serial.println(feedid);
          }
        }
        break;
    }
    lastSyncTime = millis();
  } while(0);
}

void TeleClientUDP::shutdown()
{
  if (login) {
    notify(EVENT_LOGOUT);
    login = false;
    net.close();
  }
  net.end();
  Serial.println("CELL OFF");
}
