bool TeleClientHTTP::notify(byte event, const char* payload)
{
  char url[256];
  snprintf(url, sizeof(url), "%s/notify/%s?EV=%u&SSI=%d&VIN=%s", SERVER_PATH, devid,
    (unsigned int)event, (int)rssi, vin);
  if (event == EVENT_LOGOUT) login = false;
  return net.send(METHOD_GET, url, true) && net.receive();
}

bool TeleClientHTTP::transmit(const char* packetBuffer, unsigned int packetSize)
{
  if (net.state() != HTTP_CONNECTED) {
    // reconnect if disconnected
    if (!connect()) {
      return false;
    }
  }

  char url[256];
  bool success = false;
  int len;
#if SERVER_METHOD == PROTOCOL_METHOD_GET
  if (gd && gd->ts) {
    len = snprintf(url, sizeof(url), "%s/push?id=%s&timestamp=%s&lat=%f&lon=%f&altitude=%d&speed=%f&heading=%d",
      SERVER_PATH, devid, isoTime,
      gd->lat, gd->lng, (int)gd->alt, gd->speed, (int)gd->heading);
  } else {
    len = snprintf(url, sizeof(url), "%s/push?id=%s", SERVER_PATH, devid);
  }
  success = net.send(METHOD_GET, url, true);
#else
  len = snprintf(url, sizeof(url), "%s/post/%s", SERVER_PATH, devid);
  Serial.print("URL:");
  Serial.println(url);
  success = net.send(METHOD_POST, url, true, packetBuffer, packetSize);
  len += packetSize;
#endif
  if (!success) {
    Serial.println("Connection closed");
    net.close();
    return false;
  } else {
    txBytes += len;
    txCount++;
  }

  // check response
  int bytes = 0;
  char* response = net.receive(&bytes);
  if (!response) {
    // close connection on receiving timeout
    Serial.println("No HTTP response");
    net.close();
    return false;
  }
  Serial.println(response);
  if (net.code() == 200) {
    // successful
    lastSyncTime = millis();
    rxBytes += bytes;
  }
  return true;
}

bool TeleClientHTTP::connect()
{
  if (!started) {
    started = net.open();
  }

  // connect to HTTP server
  bool success = false;

  for (byte attempts = 0; !success && attempts < 3; attempts++) {
    success = net.open(SERVER_HOST, SERVER_PORT);
    if (!success) {
      net.close();
      delay(1000);
    }
  }
  if (!success) {
    Serial.println("Error connecting to server");
    return false;
  }
  if (!login) {
    Serial.print("LOGIN(");
    Serial.print(SERVER_HOST);
    Serial.print(':');
    Serial.print(SERVER_PORT);
    Serial.println(")...");
    // log in or reconnect to Freematics Hub
    if (notify(EVENT_LOGIN)) {
      lastSyncTime = millis();
      login = true;
    }
  }
  return true;
}

bool TeleClientHTTP::ping()
{
  return connect();
}

void TeleClientHTTP::shutdown()
{
  if (login) {
    notify(EVENT_LOGOUT);
    login = false;
  }
  net.close();
  net.end();
  started = false;
  Serial.println("CELL OFF");
}